package com.mythicconverter;

import org.bukkit.configuration.ConfigurationSection;
import org.bukkit.configuration.file.YamlConfiguration;

import java.io.File;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.io.FileOutputStream;
import java.nio.charset.StandardCharsets;
import java.util.*;
import java.util.logging.Logger;

/**
 * Core conversion engine that reads MMOItems YAML item files and produces
 * MythicCrucible-compatible YAML output.
 * <p>
 * Each MMOItems type file (e.g. {@code SWORD.yml}) contains one or more items
 * keyed by their internal ID. Item data is typically nested under a {@code base}
 * subsection. The converter scans every key in the item data, matches it against
 * the configured {@link StatMappings}, and emits the appropriate MythicCrucible
 * YAML structure (Attributes, Stats, Enchantments, Options, etc.).
 * </p>
 * <p>
 * Features that cannot be directly converted (abilities, gem sockets, soulbound,
 * item sets, permanent effects) are emitted as YAML comments with migration hints.
 * </p>
 *
 * @see StatMappings
 */
public class ItemConverter {

    /** Logger for conversion progress and error reporting. */
    private final Logger logger;

    /**
     * Creates a new converter instance.
     *
     * @param logger the logger to use for conversion messages
     */
    public ItemConverter(Logger logger) {
        this.logger = logger;
    }

    /**
     * Convert all items in an MMOItems type file to MythicCrucible format.
     *
     * @param inputFile  MMOItems YAML file (e.g. SWORD.yml)
     * @param outputFile Output MythicCrucible YAML file
     * @param typeName   The MMOItems type name (e.g. "SWORD")
     * @return number of items converted
     */
    public int convertFile(File inputFile, File outputFile, String typeName) throws IOException {
        YamlConfiguration config = YamlConfiguration.loadConfiguration(inputFile);
        Set<String> itemIds = config.getKeys(false);

        if (itemIds.isEmpty()) return 0;

        StringBuilder output = new StringBuilder();
        output.append("# MythicCrucible items converted from MMOItems type: ").append(typeName).append("\n");
        output.append("# Generated by MythicConverter\n\n");

        int count = 0;
        for (String itemId : itemIds) {
            ConfigurationSection itemSection = config.getConfigurationSection(itemId);
            if (itemSection == null) continue;

            // MMOItems stores item data under "base" subsection
            ConfigurationSection base = itemSection.getConfigurationSection("base");
            if (base == null) {
                // Some configs might not have a "base" section; try the item section directly
                base = itemSection;
            }

            String converted = convertItem(itemId, base, typeName);
            if (converted != null && !converted.isEmpty()) {
                output.append(converted).append("\n");
                count++;
            }
        }

        // Write output
        outputFile.getParentFile().mkdirs();
        try (OutputStreamWriter writer = new OutputStreamWriter(new FileOutputStream(outputFile), StandardCharsets.UTF_8)) {
            writer.write(output.toString());
        }

        logger.info("Converted " + count + " items from " + typeName + " -> " + outputFile.getName());
        return count;
    }

    /**
     * Converts a single MMOItems item into a MythicCrucible YAML block.
     * <p>
     * Reads material, display name, lore, enchantments, attributes, custom stats,
     * model data, hide flags, options (unbreakable, dye color, skull texture), and
     * various MMOItems-specific features. Attributes are grouped under the correct
     * equipment slot as determined by {@link StatMappings#getSlotForType(String)}.
     * Percent-based stats are divided by 100 before output.
     * </p>
     *
     * @param itemId   the internal item ID (used as the top-level YAML key)
     * @param base     the configuration section containing the item's data
     * @param typeName the MMOItems type name (e.g. "SWORD") for slot resolution
     * @return the formatted MythicCrucible YAML string, or empty if nothing to convert
     */
    private String convertItem(String itemId, ConfigurationSection base, String typeName) {
        StringBuilder sb = new StringBuilder();
        StringBuilder comments = new StringBuilder();

        // Collect data
        String material = base.getString("material", "STONE").toUpperCase();
        String displayName = base.getString("name", "");
        List<String> lore = base.getStringList("lore");
        Map<String, String> attributes = new LinkedHashMap<>();
        List<String> stats = new ArrayList<>();
        List<String> enchantments = new ArrayList<>();
        Map<String, String> options = new LinkedHashMap<>();
        List<String> hideFlags = new ArrayList<>();

        String slot = StatMappings.getSlotForType(typeName);

        // --- Scan all keys for attributes and stats ---
        for (String key : base.getKeys(false)) {
            String lowerKey = key.toLowerCase().replace("_", "-");

            // Check if it's a vanilla attribute
            if (StatMappings.ATTRIBUTE_MAP.containsKey(lowerKey)) {
                double value = extractDouble(base, key);
                if (value != 0) {
                    // Convert percent stats: divide by 100
                    if (StatMappings.PERCENT_STATS.contains(lowerKey)) {
                        value = value / 100.0;
                    }

                    String mapping = StatMappings.ATTRIBUTE_MAP.get(lowerKey);
                    // Mapping can be "AttributeName" or "AttributeName OPERATION"
                    String[] parts = mapping.split("\\s+", 2);
                    String attrName = parts[0];
                    String operation = parts.length > 1 ? parts[1] : null;

                    // Build the value string: "<value>" or "<value> <operation>"
                    String valueStr = formatNumber(value);
                    if (operation != null && !operation.isEmpty()) {
                        valueStr = valueStr + " " + operation;
                    }
                    attributes.put(attrName, valueStr);
                }
                continue;
            }

            // Check if it's a custom stat
            if (StatMappings.STAT_MAP.containsKey(lowerKey)) {
                double value = extractDouble(base, key);
                if (value != 0) {
                    // Convert percent stats: divide by 100
                    if (StatMappings.PERCENT_STATS.contains(lowerKey)) {
                        value = value / 100.0;
                    }
                    String mythicKey = StatMappings.STAT_MAP.get(lowerKey);
                    stats.add(mythicKey + " " + formatNumber(value));
                }
                continue;
            }
        }

        // --- Custom Model Data ---
        if (base.contains("custom-model-data")) {
            int cmd = extractInt(base, "custom-model-data");
            if (cmd > 0) {
                sb.append("  Model: ").append(cmd).append("\n");
            }
        }

        // --- Enchantments ---
        ConfigurationSection enchSection = base.getConfigurationSection("enchants");
        if (enchSection != null) {
            for (String enchKey : enchSection.getKeys(false)) {
                int level = extractInt(enchSection, enchKey);
                if (level > 0) {
                    enchantments.add(enchKey.toUpperCase() + ":" + level);
                } else {
                    enchantments.add(enchKey.toUpperCase());
                }
            }
        }

        // --- Unbreakable ---
        if (base.getBoolean("unbreakable", false)) {
            options.put("Unbreakable", "true");
        }

        // --- Dye Color ---
        if (base.isConfigurationSection("dye-color")) {
            ConfigurationSection dye = base.getConfigurationSection("dye-color");
            int r = dye.getInt("red", 0);
            int g = dye.getInt("green", 0);
            int b = dye.getInt("blue", 0);
            options.put("Color", r + "," + g + "," + b);
        } else if (base.isString("dye-color")) {
            options.put("Color", base.getString("dye-color"));
        }

        // --- Hide Flags ---
        if (base.getBoolean("hide-enchants", false)) {
            hideFlags.add("ENCHANTS");
        }
        if (base.getBoolean("hide-potion-effects", false)) {
            hideFlags.add("POTION_EFFECTS");
        }
        if (base.getBoolean("hide-dye", false)) {
            hideFlags.add("DYE");
        }
        if (base.getBoolean("hide-armor-trim", false)) {
            hideFlags.add("ARMOR_TRIM");
        }

        // --- Skull Texture ---
        if (base.isConfigurationSection("skull-texture")) {
            ConfigurationSection skull = base.getConfigurationSection("skull-texture");
            String value = skull.getString("value", skull.getString("url", ""));
            if (!value.isEmpty()) {
                options.put("SkinTexture", value);
            }
        }

        // --- Max Durability ---
        if (base.contains("max-durability")) {
            int dur = extractInt(base, "max-durability");
            if (dur > 0) {
                comments.append("  # max-durability: ").append(dur)
                        .append(" (MythicCrucible uses custom durability via Skills or ItemData)\n");
            }
        }

        // --- Required Level ---
        if (base.contains("required-level")) {
            int lvl = extractInt(base, "required-level");
            if (lvl > 0) {
                sb.append("  EquipLevel: ").append(lvl).append("\n");
            }
        }

        // --- MMOItems-specific features (logged as comments) ---
        if (base.contains("ability")) {
            comments.append("  # ABILITIES: This item has MMOItems abilities. Recreate as MythicMobs Skills.\n");
            if (base.isList("ability")) {
                for (Object abilityObj : base.getList("ability")) {
                    comments.append("  #   - ").append(abilityObj.toString()).append("\n");
                }
            } else if (base.isConfigurationSection("ability")) {
                for (String abilityKey : base.getConfigurationSection("ability").getKeys(false)) {
                    comments.append("  #   - ").append(abilityKey).append("\n");
                }
            }
        }

        if (base.contains("gem-sockets")) {
            comments.append("  # GEM SOCKETS: Use MythicCrucible Augments system instead.\n");
        }
        if (base.contains("soulbound")) {
            comments.append("  # SOULBOUND: Use MythicMobs Skills/Conditions for soulbound behavior.\n");
        }
        if (base.contains("item-set")) {
            comments.append("  # ITEM SET: ").append(base.getString("item-set", ""))
                    .append(" - Use MythicCrucible Equipment Sets.\n");
        }
        if (base.contains("tier")) {
            comments.append("  # TIER: ").append(base.getString("tier", ""))
                    .append(" - Configure manually in MythicCrucible.\n");
        }
        if (base.contains("perm-effects")) {
            comments.append("  # PERMANENT EFFECTS: Use MythicMobs Skills with ~onEquip trigger.\n");
            if (base.isConfigurationSection("perm-effects")) {
                for (String effectKey : base.getConfigurationSection("perm-effects").getKeys(false)) {
                    int amplifier = base.getConfigurationSection("perm-effects").getInt(effectKey, 0);
                    comments.append("  #   - ").append(effectKey).append(": ").append(amplifier).append("\n");
                }
            }
        }
        if (base.getBoolean("two-handed", false)) {
            comments.append("  # TWO-HANDED: No direct MythicCrucible equivalent.\n");
        }

        // === Build the MythicCrucible YAML output ===
        StringBuilder result = new StringBuilder();
        result.append(itemId).append(":\n");
        result.append("  Material: ").append(material).append("\n");

        if (!displayName.isEmpty()) {
            result.append("  Display: '").append(displayName.replace("'", "''")).append("'\n");
        }

        // Model (custom model data) - already in sb
        result.append(sb);

        // Lore
        if (!lore.isEmpty()) {
            result.append("  Lore:\n");
            for (String line : lore) {
                result.append("  - '").append(line.replace("'", "''")).append("'\n");
            }
        }

        // Enchantments
        if (!enchantments.isEmpty()) {
            result.append("  Enchantments:\n");
            for (String ench : enchantments) {
                result.append("  - ").append(ench).append("\n");
            }
        }

        // Attributes (per-slot)
        if (!attributes.isEmpty() && !slot.isEmpty()) {
            result.append("  Attributes:\n");
            result.append("    ").append(slot).append(":\n");
            for (Map.Entry<String, String> entry : attributes.entrySet()) {
                result.append("      ").append(entry.getKey()).append(": ").append(entry.getValue()).append("\n");
            }
        } else if (!attributes.isEmpty()) {
            // No slot (accessory, consumable, etc.) - put attributes without slot
            result.append("  Attributes:\n");
            for (Map.Entry<String, String> entry : attributes.entrySet()) {
                result.append("    ").append(entry.getKey()).append(": ").append(entry.getValue()).append("\n");
            }
        }

        // Stats
        if (!stats.isEmpty()) {
            result.append("  Stats:\n");
            for (String stat : stats) {
                result.append("  - ").append(stat).append("\n");
            }
        }

        // Hide flags
        if (!hideFlags.isEmpty()) {
            result.append("  Hide:\n");
            for (String flag : hideFlags) {
                result.append("  - ").append(flag).append("\n");
            }
        }

        // Options
        if (!options.isEmpty()) {
            result.append("  Options:\n");
            for (Map.Entry<String, String> entry : options.entrySet()) {
                result.append("    ").append(entry.getKey()).append(": ").append(entry.getValue()).append("\n");
            }
        }

        // Comments for manual conversion
        if (comments.length() > 0) {
            result.append(comments);
        }

        return result.toString();
    }

    // --- Utility methods ---

    /**
     * Extracts a numeric value from a config key, handling double, int, and string representations.
     *
     * @param section the configuration section to read from
     * @param key     the key to extract
     * @return the numeric value, or {@code 0} if the key is missing or non-numeric
     */
    private double extractDouble(ConfigurationSection section, String key) {
        if (section.isDouble(key)) return section.getDouble(key);
        if (section.isInt(key)) return section.getInt(key);
        if (section.isString(key)) {
            try {
                return Double.parseDouble(section.getString(key));
            } catch (NumberFormatException ignored) {}
        }
        return 0;
    }

    /**
     * Extracts an integer value from a config key, handling int, double (truncated), and string representations.
     *
     * @param section the configuration section to read from
     * @param key     the key to extract
     * @return the integer value, or {@code 0} if the key is missing or non-numeric
     */
    private int extractInt(ConfigurationSection section, String key) {
        if (section.isInt(key)) return section.getInt(key);
        if (section.isDouble(key)) return (int) section.getDouble(key);
        if (section.isString(key)) {
            try {
                return Integer.parseInt(section.getString(key));
            } catch (NumberFormatException ignored) {}
        }
        return 0;
    }

    /**
     * Formats a double for YAML output. Whole numbers are rendered without a decimal
     * point (e.g. {@code 5} instead of {@code 5.0}).
     *
     * @param value the numeric value to format
     * @return the formatted string representation
     */
    private String formatNumber(double value) {
        if (value == (long) value) {
            return String.valueOf((long) value);
        }
        return String.valueOf(value);
    }
}
